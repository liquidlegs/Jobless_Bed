use console::style;
use comfy_table::{Table, Cell, Row, Color};
use reqwest::{blocking::ClientBuilder, header::{USER_AGENT, HOST, ACCEPT, CONTENT_LENGTH}, Method};

use super::{GeneralError, MbQueryType, mb_file_json::{MbQuery, Vendor}, CombinedTable};

pub mod mb_consts {
  pub const URL: &str = "https://mb-api.abuse.ch/api/v1/";
  pub const HOST: &str = "mb-api.abuse.ch";
  pub const G_RECENT: &str = "get_recent";
  pub const G_FILE_TYPE: &str = "get_file_type";
  pub const G_INFO: &str = "get_info";
}

#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)]
pub enum SearchType {
  FileType,
  Signature,
  Tag,
  YaraRule,
}

#[derive(Debug, Clone, Default)]
pub struct MalwareBazaar {
  pub debug: bool,
  pub raw_json: bool,
  pub api_key: String,
}
impl MalwareBazaar {

  /**function parses malware bazaar API repsonses and returns them as a structure.
   * Params:
   *  repsonse: String {The API repsonse}
   * Returns MbQuery
   */
  pub fn parse_response(response: String) -> MbQuery {
    let mut out = MbQuery::default();
    let (tx, rx) = std::sync::mpsc::channel::<MbQuery>();

    std::thread::spawn(Box::new(move || {
      match serde_json::from_str::<MbQuery>(&response) {
        Ok(s) => {

          match tx.send(s) {
            Ok(_) => {}
            Err(e) => { println!("{e}"); }
          }
        }
        Err(e) => { println!("{e}"); }
      }
    }));

    match rx.recv() {
      Ok(r) => { out = r; }
      Err(_) => {}
    }
    
    out
  }

  /**Function takes the response from the malware bazaar API and builds a table with general information and displays it to the console
   * Params:
   *  &self,
   *  params: String {Contains the file type to search and the number of items to return Eg: (docx:100)}
   *  search: String {Determines the filter to search with}
   * Returns Option<CombinedTable>
   */
  pub fn get_query_items(&self, params: String, search: SearchType) -> Option<CombinedTable> {
    let mut response = String::new();
    let mut title_cell = String::new();

    // Sets the title row string to the type search performed.
    if search == SearchType::FileType {
      match Self::query_file_type(&self.api_key, params) {
        Ok(s) => {
          response.push_str(s.as_str());
          title_cell.push_str("Results by file-type");
        }
        Err(e) => {
          println!("{e}");
          return None;
        }
      }
    }

    // Queries the malware bazaar API.
    let output_data = Self::parse_response(response);
    let mut out = CombinedTable::default();
    let mut title = Table::new();
    
    // Sets the title for the top row.
    title.add_row(Row::from(vec![
      Cell::from(title_cell)
      .set_alignment(comfy_table::CellAlignment::Center)
      .fg(Color::Yellow),
    ]));

    // Sets each column name.
    let mut table = Table::new();
    table.set_header(vec![
      Cell::from("Date").fg(Color::Yellow),
      Cell::from("Hash").fg(Color::Yellow),
      Cell::from("Type").fg(Color::Yellow),
      Cell::from("Sig").fg(Color::Yellow),
      Cell::from("Tags").fg(Color::Yellow),
      Cell::from("Reporter").fg(Color::Yellow),
    ]);

    let data = output_data.data?;
    let mut rows: Vec<Row> = Default::default();
    
    // Grabs parses json data.
    for i in data {
      let mut date = String::new();
      let mut hash = String::new();
      let mut filetype = String::new();
      let mut sig = String::new();
      let mut tags = String::new();
      let mut reporter = String::new();

      if let Some(d) = i.first_seen {
        date.push_str(d.as_str());
      }

      if let Some(h) = i.sha256_hash {
        hash.push_str(h.as_str());
      }

      if let Some(f) = i.file_type {
        filetype.push_str(f.as_str());
      }

      if let Some(s) = i.signature {
        sig.push_str(s.as_str());
      }

      if let Some(t) = i.tags {
        for idx in t {
          tags.push_str(idx.as_str());
          tags.push(',');
        }

        tags.pop();
      }

      if let Some(r) = i.reporter {
        reporter.push_str(r.as_str());
      }

      rows.push(
        Row::from(vec![
          Cell::from(date).fg(Color::White),
          Cell::from(hash).fg(Color::DarkCyan),
          Cell::from(filetype).fg(Color::DarkCyan),
          Cell::from(sig).fg(Color::Red),
          Cell::from(tags).fg(Color::Green),
          Cell::from(reporter).fg(Color::Yellow),
        ])
      );
    }

    // Add data to the table.
    table.add_rows(rows);
    table.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);
    title.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);

    out.title = title;
    out.contents = table;
    Some(out)
  }

  #[allow(dead_code)]
  pub fn query_tag() -> () {

  }

  #[allow(dead_code)]
  pub fn query_signature() -> () {

  }

  #[allow(dead_code)]
  pub fn query_yara_rule() -> () {

  }

  /**Function queries the malware bazaar API for up to 100 samples that were recently added to the platform or all samples
   that were added in the last 60 minutes.
   * Params:
   *  apikey: &str        {The malware bazaar api key}
   *  select: MbQueryType {The type of query you want to run}
   * Returns Result<()>
   */
  pub fn query_recent_samples(apikey: &String, select: MbQueryType) -> std::result::Result<(), GeneralError> {
    let mut selector = String::new();

    // Either view the last 100 additions to the platform or samples added within the last hour.
    if select == MbQueryType::Time {
      selector.push_str("time");
    }

    else {
      selector.push_str("100");
    }
    
    // Prepare the POST request
    let builder = ClientBuilder::new()
      .build()?
      .request(Method::POST, mb_consts::URL)
      .header(ACCEPT, "application/json")
      .header(HOST, mb_consts::HOST)
      .header(USER_AGENT, "PE Potato 0.1.0")
      .header("API-KEY", apikey)
      .header(CONTENT_LENGTH, selector.len().clone())
      .form(&[("query", mb_consts::G_RECENT), ("selector", selector.as_str())]);

    // Send the request to the malware bazaar api and view the response.
    let response = builder.send()?;
    let text = response.text()?;

    println!("{text}");

    Ok(())
  }

  /**Function queries the malware bazaar API for malware samples by file type.
   * Params:
   *  apikey: &str    {The malware bazaar api key}
   *  params: String  {A string containing the file type and the nunber of results to be returned}
   * Returns Result<()>
   */
  pub fn query_file_type(apikey: &String, params: String) -> std::result::Result<String, GeneralError> {
    let split_params: Vec<&str> = params.split(":").collect();
    let mut limit = "";
    let mut file_type = "";

    if split_params.len() < 2 {
      file_type = split_params[0];
      limit = "30";
    }
    else {
      file_type = split_params[0];
      limit = split_params[1];
    }

    // Prepare the request.
    println!("{}: building the request", style("Info").yellow().bright());
    let builder = ClientBuilder::new()
    .build()?
    .request(Method::POST, mb_consts::URL)
    .header(ACCEPT, "application/json")
    .header(HOST, mb_consts::HOST)
    .header(USER_AGENT, "PE Potato 0.1.0")
    .header("API-KEY", apikey)
    .header(CONTENT_LENGTH, 100)
    .form(&[("query", mb_consts::G_FILE_TYPE), ("file_type", file_type), ("limit", limit)]);

    // Get the response.
    println!("{}: Sending request", style("Info").yellow().bright());
    println!("{}: Waiting for response...", style("Info").yellow().bright());
    let response = builder.send()?;
    let text = response.text()?;

    // println!("{text}");

    Ok(text)
  }

  /**Function displays detailed information about a specific file.
   * Params:
   *  &self,
   *  hash: String {The file hash}
   * Returns Option<CombinedTable>
   */
  pub fn get_query_hash(&self, hash: String) -> Option<CombinedTable> {
    // Gets the API repsonse for the file hash.
    let mut response = String::new();
    match Self::query_hash(&self.api_key, hash) {
      Ok(s) => { response.push_str(s.as_str()); }
      
      Err(e) => {
        println!("{e}");
        return None;
      }
    }

    // Displays the raw json response.
    if self.raw_json.clone() == true {
      println!("{response}");
      return None;
    }

    println!("{}: At the moment hash is partially implemented. To view the raw json response, use the {} flag",
    style("Info").yellow().bright(), style("'-r'").cyan());

    // Parses the json file and stores in a structure.
    let output_data = Self::parse_response(response.clone());
    let mut out = CombinedTable::default();
    let mut title = Table::new();
    
    // Sets the title of the table.
    title.add_row(
      Row::from(vec![
        Cell::from("Results by hash")
        .set_alignment(comfy_table::CellAlignment::Center)
        .fg(Color::Yellow),
      ])
    );

    // Stores each column name as an indivudal column that will be displayed on the side of the table.
    let header = vec![
      "sha256\nsha3_384\nsha1\nmd5\nimphash\ntlsh\ntelfhash\ngimphash\nssdeep\nfirst seen\nlast seen\nfile name\n",
      "file size\nfile type\nreporter\norigin country\nsignature\ncomment\ndelivery method\nclamav\n",
      "uploads\ndownloads\n",
    ];

    let mut side_column = String::new();
    for i in header {
      side_column.push_str(i);
    }

    let mut table = Table::new();
    table.add_row(
      Row::from(vec![
        Cell::from("Key").fg(Color::Yellow),
        Cell::from("Value").fg(Color::Yellow)
      ])
    );

    // Sets up some strings to store the table content.
    let mut sha256_hash  = String::new();
    let mut sha3_384_hash = String::new();
    let mut sha1_hash = String::new();
    let mut md5_hash = String::new();
    
    let mut imphash = String::new();
    let mut tlsh = String::new();
    let mut telfhash = String::new();
    let mut gimphash = String::new();
    let mut ssdeep = String::new();

    let mut first_seen = String::new();
    let mut last_seen = String::new();
    let mut file_name = String::new();
    let mut file_size = String::new();
    let mut file_type = String::new();
    let mut reporter = String::new();
    let mut origin_country = String::new();
    let mut signature = String::new();
    let mut comment = String::new();
    let mut delivery_method = String::new();
    let mut clamav = String::new();
    let mut uploads = String::new();
    let mut downloads = String::new();
    let mut mail = String::new();

    // Grabs the parsed data.
    let mut data = output_data.data?;
    for i in data {
      if let Some(s) = i.sha256_hash {
        sha256_hash.push_str(s.as_str())
      }

      if let Some(s) = i.sha3_384_hash {
        sha3_384_hash.push_str(s.as_str());
      }

      if let Some(s) = i.sha1_hash {
        sha1_hash.push_str(s.as_str());
      }

      if let Some(m) = i.md5_hash {
        md5_hash.push_str(m.as_str());
      }

      if let Some(im) = i.imphash {
        imphash.push_str(im.as_str());
      }

      if let Some(t) = i.tlsh {
        tlsh.push_str(t.as_str());
      }

      if let Some(tel) = i.telfhash {
        telfhash.push_str(tel.as_str());
      }

      if let Some(g) = i.gimphash {
        gimphash.push_str(g.as_str());
      }

      if let Some(s) = i.ssdeep {
        ssdeep.push_str(s.as_str());
      }
      
      if let Some(f) = i.first_seen {
        first_seen.push_str(f.as_str());
      }

      if let Some(l) = i.last_seen {
        last_seen.push_str(l.as_str());
      }

      if let Some(f) = i.file_name {
        file_name.push_str(f.as_str());
      }

      if let Some(f) = i.file_type {
        file_type.push_str(f.as_str());
      }

      if let Some(f) = i.file_size {
        file_size.push_str(format!("{f}").as_str());
      }

      if let Some(r) = i.reporter {
        reporter.push_str(r.as_str());
      }

      if let Some(o) = i.origin_country {
        origin_country.push_str(o.as_str());
      }

      if let Some(s) = i.signature {
        signature.push_str(s.as_str());
      }

      if let Some(c) = i.comment {
        comment.push_str(c.as_str());
      }

      if let Some(d) = i.delivery_method {
        delivery_method.push_str(d.as_str());
      }

      if let Some(it) = i.intelligence {
        // contains uploads, downloads and clamav
        if let Some(clam) = it.clamav {
          for idx in clam {
            clamav.push_str(idx.as_str());
            clamav.push('\n');
          }

          clamav.pop();
        }

        if let Some(up) = it.uploads {
          uploads.push_str(up.as_str());
        }

        if let Some(down) = it.download {
          downloads.push_str(down.as_str());
        }

        if let Some(m) = it.mail {
          mail.push_str(m.as_str());
        }
      }
    }

    table.add_rows(vec![
      Row::from(vec![
        Cell::from("sha256").fg(Color::Yellow), Cell::from(sha256_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("sha3_384").fg(Color::Yellow), Cell::from(sha3_384_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("sha1").fg(Color::Yellow), Cell::from(sha1_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("md5").fg(Color::Yellow), Cell::from(md5_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("imphash").fg(Color::Yellow), Cell::from(imphash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("tlsh").fg(Color::Yellow), Cell::from(tlsh).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("telfhash").fg(Color::Yellow), Cell::from(telfhash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("gimphash").fg(Color::Yellow), Cell::from(gimphash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("ssdeep").fg(Color::Yellow), Cell::from(ssdeep).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("first seen").fg(Color::Yellow), Cell::from(first_seen).fg(Color::White)
      ]),

      Row::from(vec![
        Cell::from("last seen").fg(Color::Yellow), Cell::from(last_seen).fg(Color::White)
      ]),

      Row::from(vec![
        Cell::from("file name").fg(Color::Yellow), Cell::from(file_name).fg(Color::Green)
      ]),

      Row::from(vec![
        Cell::from("file size").fg(Color::Yellow), Cell::from(file_size).fg(Color::DarkYellow)
      ]),

      Row::from(vec![
        Cell::from("file type").fg(Color::Yellow), Cell::from(file_type).fg(Color::Green)
      ]),

      Row::from(vec![
        Cell::from("reporter").fg(Color::Yellow), Cell::from(reporter).fg(Color::Cyan)
      ]),

      Row::from(vec![
        Cell::from("origin_country").fg(Color::Yellow), Cell::from(origin_country).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("signature").fg(Color::Yellow), Cell::from(signature).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("comment").fg(Color::Yellow), Cell::from(comment).fg(Color::Green)
      ]),

      Row::from(vec![
        Cell::from("delivery method").fg(Color::Yellow), Cell::from(delivery_method).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("clamav").fg(Color::Yellow), Cell::from(clamav).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("uploads").fg(Color::Yellow), Cell::from(uploads).fg(Color::DarkYellow)
      ]),

      Row::from(vec![
        Cell::from("downloads").fg(Color::Yellow), Cell::from(downloads).fg(Color::DarkYellow)
      ]),

      Row::from(vec![
        Cell::from("mail").fg(Color::Yellow), Cell::from(mail).fg(Color::Green)
      ]),
    ]);

    title.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);
    table.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);

    out.title = title;
    out.contents = table;
    Some(out)
  }


  pub fn unload_vendor_intel(intel: Vendor) -> Option<String> {
    let mut out = String::new();
    

    Some(out)
  }


  /**Function queries the malware bazaar APU for a single hash.
   * Params:
   *  apikey: String  {The malware bazaar API key}
   *  hash: String    {The file hash}
   * Returns Result<String, GeneralError>
   */
  pub fn query_hash(apikey: &String, hash: String) -> std::result::Result<String, GeneralError> {
    let builder = ClientBuilder::new()
    .build()?
    .request(Method::POST, mb_consts::URL)
    .header(ACCEPT, "application/json")
    .header(HOST, mb_consts::HOST)
    .header(USER_AGENT, "PE Potato 0.1.0")
    .header("API-KEY", apikey)
    .header(CONTENT_LENGTH, 100)
    .form(&[("query", mb_consts::G_INFO), ("hash", hash.as_str())]);
    
    let response = builder.send()?;
    let text = response.text()?;
    
    Ok(text)
  }
}



