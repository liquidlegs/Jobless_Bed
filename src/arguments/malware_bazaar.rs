use console::style;
use comfy_table::{Table, Cell, Row, Color};
use reqwest::{blocking::ClientBuilder, header::{USER_AGENT, HOST, ACCEPT, CONTENT_LENGTH}, Method};

use self::mb_consts::DF_N_RESULTS;
use super::{GeneralError, MbQueryType, mb_file_json::{MbQuery, Vendor, MbYaraRule}, CombinedTable,
CTerm};

pub mod mb_consts {
  pub const URL: &str = "https://mb-api.abuse.ch/api/v1/";
  pub const HOST: &str = "mb-api.abuse.ch";
  pub const G_RECENT: &str = "get_recent";
  pub const G_FILE_TYPE: &str = "get_file_type";
  pub const G_INFO: &str = "get_info";
  pub const G_TAG_INFO: &str = "get_taginfo";
  pub const G_SIG_INFO: &str = "get_siginfo";
  pub const DF_N_RESULTS: usize = 30;
}

#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)]
pub enum SearchType {
  FileType,       // O
  Signature,      // O
  Tag,            // O
  YaraRule,       // X
  ClamAv,         // X
  ImpHash,        // X
  GimpHash,       // X
  Tlsh,           // X
  TelfHash,       // X
  Dhash,          // X
}

#[derive(Debug, Clone, Default)]
pub struct MalwareBazaar {
  pub debug: bool,
  pub raw_json: bool,
  pub api_key: String,
}
impl MalwareBazaar {

  /**function parses malware bazaar API repsonses and returns them as a structure.
   * Params:
   *  repsonse: String {The API repsonse}
   * Returns MbQuery
   */
  pub fn parse_response(response: String) -> MbQuery {
    let mut out = MbQuery::default();
    let (tx, rx) = std::sync::mpsc::channel::<MbQuery>();

    std::thread::spawn(Box::new(move || {
      match serde_json::from_str::<MbQuery>(&response) {
        Ok(s) => {

          match tx.send(s) {
            Ok(_) => {}
            Err(e) => { println!("{e}"); }
          }
        }
        Err(e) => { println!("{e}"); }
      }
    }));

    match rx.recv() {
      Ok(r) => { out = r; }
      Err(_) => {}
    }
    
    out
  }

  /**Function parses parameter strings received from the command line and checks if they are correct.
   * Params:
   *  params: String {The parameters that will be parsed}
   * Returns (String, String)
   */
  pub fn parse_parameters(params: String) -> (String, String) {
    let split_params: Vec<&str> = params.split(":").collect();
    let mut limit = String::new();
    let mut param = String::new();

    if split_params.len() < 2 {
      param.push_str(split_params[0]);
      limit.push_str("30");
    }
    else {
      param.push_str(split_params[0]);
      limit.push_str(split_params[1]);
    }

    (param, limit)
  }

  /**Function takes the response from the malware bazaar API and builds a table with general information and displays it to the console
   * Params:
   *  &self,
   *  params: String {Contains the file type to search and the number of items to return Eg: (docx:100)}
   *  search: String {Determines the filter to search with}
   * Returns Option<CombinedTable>
   */
  pub fn get_query_items(&self, params: String, search: SearchType) -> Option<CombinedTable> {
    let mut response = String::new();
    let mut title_cell = String::new();
    let mut n_items: usize = 0;
    let c_params = params.clone();

    let split_params: Vec<&str> = c_params.split(":").collect();
    if split_params.len() > 1 {
      
      match split_params[1].parse::<usize>() {
        Ok(s) => {
          n_items = s;
        }

        Err(_) => {}
      }
    }
    
    else {
      n_items = DF_N_RESULTS;
    }

    // Sets the title row string to the type search performed.
    if search == SearchType::FileType {
      match Self::query_file_type(&self.api_key, params) {
        Ok(s) => {
          response.push_str(s.as_str());
          title_cell.push_str("Results by File-Type");

          if n_items > 0 {
            title_cell.push_str(format!(" ({})", n_items).as_str());
          }
        }
        
        Err(e) => {
          println!("{e}");
          return None;
        }
      }
    }

    else if search == SearchType::Tag {
      match Self::query_tag(&self.api_key, params) {
        Ok(s) => {
          response.push_str(s.as_str());
          title_cell.push_str("Results by Tag");

          if n_items > 0 {
            title_cell.push_str(format!(" ({})", n_items).as_str());
          }
        }

        Err(e) => {
          println!("{e}");
          return None;
        }
      }
    }

    else if search == SearchType::Signature {
      match Self::query_signature(&self.api_key, params) {
        Ok(s) => {
          response.push_str(s.as_str());
          title_cell.push_str("Results by Signature");

          if n_items > 0 {
            title_cell.push_str(format!(" ({})", n_items).as_str());
          }
        }

        Err(e) => {
          println!("{e}");
          return None;
        }
      }
    }

    if self.raw_json.clone() == true {
      println!("{response}");
      return None;
    }

    // Queries the malware bazaar API.
    let output_data = Self::parse_response(response);
    let mut out = CombinedTable::default();
    let mut title = Table::new();
    
    // Sets the title for the top row.
    title.add_row(Row::from(vec![
      Cell::from(title_cell)
      .set_alignment(comfy_table::CellAlignment::Center)
      .fg(Color::Yellow),
    ]));

    // Sets each column name.
    let mut table = Table::new();
    table.set_header(vec![
      Cell::from("Date").bg(Color::DarkBlue).fg(Color::White),
      Cell::from("Hash").bg(Color::DarkBlue).fg(Color::White),
      Cell::from("Type").bg(Color::DarkBlue).fg(Color::White),
      Cell::from("Sig").bg(Color::DarkBlue).fg(Color::White),
      Cell::from("Tags").bg(Color::DarkBlue).fg(Color::White),
      Cell::from("Reporter").bg(Color::DarkBlue).fg(Color::White),
    ]);

    let data = output_data.data?;
    let mut rows: Vec<Row> = Default::default();
    
    // Grabs parses json data.
    for i in data {
      let mut date = String::new();
      let mut hash = String::new();
      let mut filetype = String::new();
      let mut sig = String::new();
      let mut tags = String::new();
      let mut reporter = String::new();

      if let Some(d) = i.first_seen {
        date.push_str(d.as_str());
      }

      if let Some(h) = i.sha256_hash {
        hash.push_str(h.as_str());
      }

      if let Some(f) = i.file_type {
        filetype.push_str(f.as_str());
      }

      if let Some(s) = i.signature {
        sig.push_str(s.as_str());
      }

      if let Some(t) = i.tags {
        for idx in t {
          tags.push_str(idx.as_str());
          tags.push(',');
        }

        tags.pop();
      }

      if let Some(r) = i.reporter {
        reporter.push_str(r.as_str());
      }

      rows.push(
        Row::from(vec![
          Cell::from(date).fg(Color::White),
          Cell::from(hash).fg(Color::DarkCyan),
          Cell::from(filetype).fg(Color::DarkCyan),
          Cell::from(sig).fg(Color::Red),
          Cell::from(tags).fg(Color::Green),
          Cell::from(reporter).fg(Color::Yellow),
        ])
      );
    }

    // Add data to the table.
    table.add_rows(rows);
    table.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);
    title.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);

    out.title = title;
    out.contents = table;
    Some(out)
  }

   /**Function queries the malware bazaar API for malware samples by tag.
   * Params:
   *  apikey: &str    {The malware bazaar api key}
   *  params: String  {A string containing the tag and the nunber of results to be returned}
   * Returns Result<String, GeneralError>
   */
  pub fn query_tag(apikey: &String, params: String) -> std::result::Result<String, GeneralError> {
    let pair = Self::parse_parameters(params);
    let tag = pair.0;
    let limit = pair.1;

    // Prepare the request.
    println!("{}: building the request", style("Info").yellow().bright());
    let builder = ClientBuilder::new()
    .build()?
    .request(Method::POST, mb_consts::URL)
    .header(ACCEPT, "application/json")
    .header(HOST, mb_consts::HOST)
    .header(USER_AGENT, "PE Potato 0.1.0")
    .header("API-KEY", apikey)
    .header(CONTENT_LENGTH, 100)
    .form(&[("query", mb_consts::G_TAG_INFO), ("tag", tag.as_str()), ("limit", limit.as_str())]);

    // Get the response.
    println!("{}: Sending request", style("Info").yellow().bright());
    println!("{}: Waiting for response...", style("Info").yellow().bright());
    let response = builder.send()?;
    let text = response.text()?;

    Ok(text)
  }


    /**Function queries the malware bazaar API for malware samples by signature.
   * Params:
   *  apikey: &str    {The malware bazaar api key}
   *  params: String  {A string containing the signature and the nunber of results to be returned}
   * Returns Result<String, GeneralError>
   */
  pub fn query_signature(apikey: &String, params: String) -> std::result::Result<String, GeneralError> {
    let pair = Self::parse_parameters(params);
    let sig = pair.0;
    let limit = pair.1;

    // Prepare the request.
    println!("{}: building the request", style("Info").yellow().bright());
    let builder = ClientBuilder::new()
    .build()?
    .request(Method::POST, mb_consts::URL)
    .header(ACCEPT, "application/json")
    .header(HOST, mb_consts::HOST)
    .header(USER_AGENT, "PE Potato 0.1.0")
    .header("API-KEY", apikey)
    .header(CONTENT_LENGTH, 100)
    .form(&[("query", mb_consts::G_SIG_INFO), ("tag", sig.as_str()), ("limit", limit.as_str())]);

    // Get the response.
    println!("{}: Sending request", style("Info").yellow().bright());
    println!("{}: Waiting for response...", style("Info").yellow().bright());
    let response = builder.send()?;
    let text = response.text()?;

    Ok(text)
  }

  #[allow(dead_code)]
  pub fn query_yara_rule() -> () {

  }

  /**Function queries the malware bazaar API for up to 100 samples that were recently added to the platform or all samples
   that were added in the last 60 minutes.
   * Params:
   *  apikey: &str        {The malware bazaar api key}
   *  select: MbQueryType {The type of query you want to run}
   * Returns Result<()>
   */
  pub fn query_recent_samples(apikey: &String, select: MbQueryType) -> std::result::Result<(), GeneralError> {
    let mut selector = String::new();

    // Either view the last 100 additions to the platform or samples added within the last hour.
    if select == MbQueryType::Time {
      selector.push_str("time");
    }

    else {
      selector.push_str("100");
    }
    
    // Prepare the POST request
    let builder = ClientBuilder::new()
      .build()?
      .request(Method::POST, mb_consts::URL)
      .header(ACCEPT, "application/json")
      .header(HOST, mb_consts::HOST)
      .header(USER_AGENT, "PE Potato 0.1.0")
      .header("API-KEY", apikey)
      .header(CONTENT_LENGTH, selector.len().clone())
      .form(&[("query", mb_consts::G_RECENT), ("selector", selector.as_str())]);

    // Send the request to the malware bazaar api and view the response.
    let response = builder.send()?;
    let text = response.text()?;

    println!("{text}");

    Ok(())
  }

  /**Function queries the malware bazaar API for malware samples by file type.
   * Params:
   *  apikey: &str    {The malware bazaar api key}
   *  params: String  {A string containing the file type and the nunber of results to be returned}
   * Returns Result<String, GeneralError>
   */
  pub fn query_file_type(apikey: &String, params: String) -> std::result::Result<String, GeneralError> {
    let pair = Self::parse_parameters(params);
    let file_type = pair.0;
    let limit = pair.1;

    // Prepare the request.
    println!("{}: building the request", style("Info").yellow().bright());
    let builder = ClientBuilder::new()
    .build()?
    .request(Method::POST, mb_consts::URL)
    .header(ACCEPT, "application/json")
    .header(HOST, mb_consts::HOST)
    .header(USER_AGENT, "PE Potato 0.1.0")
    .header("API-KEY", apikey)
    .header(CONTENT_LENGTH, 100)
    .form(&[("query", mb_consts::G_FILE_TYPE), ("file_type", file_type.as_str()), ("limit", limit.as_str())]);

    // Get the response.
    println!("{}: Sending request", style("Info").yellow().bright());
    println!("{}: Waiting for response...", style("Info").yellow().bright());
    let response = builder.send()?;
    let text = response.text()?;

    Ok(text)
  }

  /**Function displays detailed information about a specific file.
   * Params:
   *  &self,
   *  hash: String {The file hash}
   * Returns Option<(CombinedTable, CombinedTable, CombinedTable)>
   */
  pub fn get_query_hash(&self, hash: String) -> Option<(CombinedTable, CombinedTable, CombinedTable)> {
    // Gets the API repsonse for the file hash.
    let mut response = String::new();
    match Self::query_hash(&self.api_key, hash) {
      Ok(s) => { response.push_str(s.as_str()); }
      
      Err(e) => {
        println!("{e}");
        return None;
      }
    }

    // Displays the raw json response.
    if self.raw_json.clone() == true {
      println!("{response}");
      return None;
    }

    println!("{}: At the moment hash is partially implemented. To view the raw json response, use the {} flag",
    style("Info").yellow().bright(), style("'-r'").cyan());

    // Parses the json file and stores in a structure.
    let output_data = Self::parse_response(response.clone());
    let mut out_info = CombinedTable::default();
    let mut out_yara_info = CombinedTable::default();
    let mut out_intel = CombinedTable::default();
    let mut title = Table::new();
    
    // Sets the title of the table.
    title.add_row(
      Row::from(vec![
        Cell::from("Results by hash")
        .set_alignment(comfy_table::CellAlignment::Center)
        .fg(Color::Yellow),
      ])
    );

    let mut table = Table::new();
    table.add_row(
      Row::from(vec![
        Cell::from("Key").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("Value").bg(Color::DarkBlue).fg(Color::White),
      ])
    );

    // Sets up some strings to store the table content.
    let mut sha256_hash  = String::new();
    let mut sha3_384_hash = String::new();
    let mut sha1_hash = String::new();
    let mut md5_hash = String::new();
    
    let mut imphash = String::new();
    let mut tlsh = String::new();
    let mut telfhash = String::new();
    let mut gimphash = String::new();
    let mut ssdeep = String::new();

    let mut first_seen = String::new();
    let mut last_seen = String::new();
    let mut file_name = String::new();
    let mut file_size = String::new();
    let mut file_type = String::new();
    let mut reporter = String::new();
    let mut origin_country = String::new();
    let mut signature = String::new();
    let mut comment = String::new();
    let mut delivery_method = String::new();
    let mut clamav = String::new();
    let mut uploads = String::new();
    let mut downloads = String::new();
    let mut mail = String::new();

    // Grabs the parsed data.
    let mut data = output_data.data?;
    for i in data {
      if let Some(s) = i.sha256_hash {
        sha256_hash.push_str(s.as_str())
      }

      if let Some(s) = i.sha3_384_hash {
        sha3_384_hash.push_str(s.as_str());
      }

      if let Some(s) = i.sha1_hash {
        sha1_hash.push_str(s.as_str());
      }

      if let Some(m) = i.md5_hash {
        md5_hash.push_str(m.as_str());
      }

      if let Some(im) = i.imphash {
        imphash.push_str(im.as_str());
      }

      if let Some(t) = i.tlsh {
        tlsh.push_str(t.as_str());
      }

      if let Some(tel) = i.telfhash {
        telfhash.push_str(tel.as_str());
      }

      if let Some(g) = i.gimphash {
        gimphash.push_str(g.as_str());
      }

      if let Some(s) = i.ssdeep {
        ssdeep.push_str(s.as_str());
      }
      
      if let Some(f) = i.first_seen {
        first_seen.push_str(f.as_str());
      }

      if let Some(l) = i.last_seen {
        last_seen.push_str(l.as_str());
      }

      if let Some(f) = i.file_name {
        file_name.push_str(f.as_str());
      }

      if let Some(f) = i.file_type {
        file_type.push_str(f.as_str());
      }

      if let Some(f) = i.file_size {
        file_size.push_str(format!("{f}").as_str());
      }

      if let Some(r) = i.reporter {
        reporter.push_str(r.as_str());
      }

      if let Some(o) = i.origin_country {
        origin_country.push_str(o.as_str());
      }

      if let Some(s) = i.signature {
        signature.push_str(s.as_str());
      }

      if let Some(c) = i.comment {
        comment.push_str(c.as_str());
      }

      if let Some(d) = i.delivery_method {
        delivery_method.push_str(d.as_str());
      }

      if let Some(it) = i.intelligence {
        // contains uploads, downloads and clamav
        if let Some(clam) = it.clamav {
          for idx in clam {
            clamav.push_str(idx.as_str());
            clamav.push('\n');
          }

          clamav.pop();
        }

        if let Some(up) = it.uploads {
          uploads.push_str(up.as_str());
        }

        if let Some(down) = it.downloads {
          downloads.push_str(down.as_str());
        }

        if let Some(m) = it.mail {
          mail.push_str(m.as_str());
        }
      }

      if let Some(s) = i.yara_rules {
        if let Some(y) = Self::get_yara_rules(s) {
          out_yara_info = y;
        }
      }

      if let Some(s) = i.vendor_intel {
        if let Some(intel) = Self::get_vendor_intel(s) {
          out_intel = intel;
        }
      }
    }

    table.add_rows(vec![
      Row::from(vec![
        Cell::from("sha256").bg(Color::DarkGrey).fg(Color::White), Cell::from(sha256_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("sha3_384").fg(Color::White), Cell::from(sha3_384_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("sha1").bg(Color::DarkGrey).fg(Color::White), Cell::from(sha1_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("md5").fg(Color::White), Cell::from(md5_hash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("imphash").bg(Color::DarkGrey).fg(Color::White), Cell::from(imphash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("tlsh").fg(Color::White), Cell::from(tlsh).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("telfhash").bg(Color::DarkGrey).fg(Color::White), Cell::from(telfhash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("gimphash").fg(Color::White), Cell::from(gimphash).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("ssdeep").bg(Color::DarkGrey).fg(Color::White), Cell::from(ssdeep).fg(Color::DarkCyan)
      ]),

      Row::from(vec![
        Cell::from("first seen").fg(Color::White), Cell::from(first_seen).fg(Color::White)
      ]),

      Row::from(vec![
        Cell::from("last seen").bg(Color::DarkGrey).fg(Color::White), Cell::from(last_seen).fg(Color::White)
      ]),

      Row::from(vec![
        Cell::from("file name").fg(Color::White), Cell::from(file_name).fg(Color::Green)
      ]),

      Row::from(vec![
        Cell::from("file size").bg(Color::DarkGrey).fg(Color::White), Cell::from(file_size).fg(Color::DarkYellow)
      ]),

      Row::from(vec![
        Cell::from("file type").fg(Color::White), Cell::from(file_type).fg(Color::Green)
      ]),

      Row::from(vec![
        Cell::from("reporter").bg(Color::DarkGrey).fg(Color::White), Cell::from(reporter).fg(Color::Cyan)
      ]),

      Row::from(vec![
        Cell::from("origin_country").fg(Color::White), Cell::from(origin_country).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("signature").bg(Color::DarkGrey).fg(Color::White), Cell::from(signature).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("comment").fg(Color::White), Cell::from(comment).fg(Color::Green)
      ]),

      Row::from(vec![
        Cell::from("delivery method").bg(Color::DarkGrey).fg(Color::White), Cell::from(delivery_method).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("clamav").fg(Color::White), Cell::from(clamav).fg(Color::Red)
      ]),

      Row::from(vec![
        Cell::from("uploads").bg(Color::DarkGrey).fg(Color::White), Cell::from(uploads).fg(Color::Yellow)
      ]),

      Row::from(vec![
        Cell::from("downloads").fg(Color::White), Cell::from(downloads).fg(Color::Yellow)
      ]),

      Row::from(vec![
        Cell::from("mail").bg(Color::DarkGrey).fg(Color::White), Cell::from(mail).fg(Color::Green)
      ]),
    ]);

    title.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);
    table.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);

    out_info.title = title;
    out_info.contents = table;
    Some((out_info, out_yara_info, out_intel))
  }


  pub fn get_yara_rules(yara: Vec<MbYaraRule>) -> Option<CombinedTable> {
    let mut out = CombinedTable::default();
    let mut title = Table::new();

    title.add_row(Row::from(vec![
      Cell::from("Yara Rules")
      .set_alignment(comfy_table::CellAlignment::Center)
      .fg(Color::Yellow)
    ]));

    let mut table = Table::new();
    let mut rows: Vec<Row> = Default::default();
    
    for i in yara.clone() {
      let mut counter: usize = 2;
      
      if let Some(s) = i.rule_name {
        if counter % 2 == 0 {
          rows.push(Row::from(vec![
            Cell::from("Rule Name").bg(Color::DarkGrey).fg(Color::White),
            Cell::from(s.clone()).fg(Color::Green),
          ]));
        }
        
        else {
          rows.push(Row::from(vec![
            Cell::from("Rule Name").fg(Color::White),
            Cell::from(s.clone()).fg(Color::Green),
          ]));
        }

        counter += 1;
      }

      if let Some(s) = i.description {
        if counter % 2 == 0 {
          rows.push(Row::from(vec![
            Cell::from("Description").bg(Color::DarkGrey).fg(Color::White),
            Cell::from(s).fg(Color::Red),
          ]));
        }

        else {
          rows.push(Row::from(vec![
            Cell::from("Description").fg(Color::White),
            Cell::from(s).fg(Color::Red),
          ]));
        }

        counter += 1;
      }

      if let Some(s) = i.author {
        if counter % 2 == 0 {
          rows.push(Row::from(vec![
            Cell::from("Author").bg(Color::DarkGrey).fg(Color::White),
            Cell::from(s).fg(Color::DarkYellow),
          ]));
        }

        else {
          rows.push(Row::from(vec![
            Cell::from("Author").fg(Color::White),
            Cell::from(s).fg(Color::DarkYellow),
          ]));
        }

        counter += 1;
      }

      if let Some(s) = i.reference {
        if counter % 2 == 0 {
          rows.push(Row::from(vec![
            Cell::from("Reference").bg(Color::DarkGrey).fg(Color::White),
            Cell::from(s).fg(Color::DarkCyan),
          ]));
        }

        else {
          rows.push(Row::from(vec![
            Cell::from("Reference").fg(Color::White),
            Cell::from(s).fg(Color::DarkCyan),
          ]));
        }

        counter += 1;
      }

      rows.push(Row::from(vec![
        Cell::from("")
      ]));

      // counter += 1;
    }

    rows.pop();
    table.add_rows(rows);
    title.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);
    table.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);

    out.title = title;
    out.contents = table;
    Some(out)
  }


  pub fn get_colour_keyword(colour: CTerm, keyword: String) -> Color {
    match keyword.to_lowercase().as_str() {
      word if word.contains("malicious") => {
        if colour == CTerm::Fg {
          return Color::White;
        }

        else {
          return Color::DarkRed
        }
        
      }
      
      "clean" => {
        if colour == CTerm::Fg {
          return Color::Green;
        }

        else {
          return Color::Reset;
        }
      }
      
      "suspicious" => {
        if colour == CTerm::Fg {
          return Color::Yellow;
        }

        else {
          return Color::Reset;
        }
      }
      
      "unknown" | _ => {
        if colour == CTerm::Fg {
          return Color::White;
        }

        else {
          return Color::Reset;
        }
      }
    }
  }

  /**Function displays intellegence gathered from various sanboxed enviornments about a specific threat.
   * Params:
   *  intel: Vendor {Information about the threat}
   * Returns Option<CombinedTable>
   */
  pub fn get_vendor_intel(intel: Vendor) -> Option<CombinedTable> {
    let mut out = CombinedTable::default();
    let mut title = Table::new();

    title.add_row(Row::from(vec![
      Cell::from("Vendor/Sandbox Intel")
      .set_alignment(comfy_table::CellAlignment::Center)
      .fg(Color::Yellow)
    ]));

    let mut table = Table::new();
    let mut rows: Vec<Row> = Default::default();
    
    //////////////////////////////////////////////////////////////////////////////
    if let Some(a) = intel.any_dot_run {
      rows.push(Row::from(vec![
        Cell::from("ANY.RUN")
        .bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue),
      ]));

      for i in a {
        if let Some(s) = i.verdict {
          let fg = Self::get_colour_keyword(CTerm::Fg, s.clone());
          let bg = Self::get_colour_keyword(CTerm::Bg, s.clone());

          rows.push(Row::from(vec![
            Cell::from("Verdict").fg(Color::White),
            Cell::from(s.clone()).bg(bg).fg(fg),
          ]));
        }
        
        if let Some(s) = i.malware_family {
          rows.push(Row::from(vec![
            Cell::from("Malware Family").fg(Color::White),
            Cell::from(s).fg(Color::Red)
          ]));
        }
        
        if let Some(s) = i.file_name {
          rows.push(Row::from(vec![
            Cell::from("File Name").fg(Color::White),
            Cell::from(s).fg(Color::Green)
          ]));
        }
        
        if let Some(s) = i.date {
          rows.push(Row::from(vec![
            Cell::from("Date").fg(Color::White),
            Cell::from(s).fg(Color::White)
          ]));
        }

        if let Some(s) = i.analysis_url {
          rows.push(Row::from(vec![
            Cell::from("Url").fg(Color::White),
            Cell::from(s).fg(Color::DarkCyan)
          ]));
        }

        if let Some(t) = i.tags {
          let mut tags = String::new();

          for idx in t {
            tags.push_str(format!("{idx}\n").as_str());
          }

          tags.pop();
          rows.push(Row::from(vec![
            Cell::from("Tags").fg(Color::White),
            Cell::from(tags).fg(Color::Green)
          ]));
        }
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////
    if let Some(a) = intel.cert_pl_mwdb {
      rows.push(Row::from(vec![
        Cell::from("Cert PL MWDB").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue).fg(Color::White)
      ]));

      if let Some(d) = a.detection {
        let fg = Self::get_colour_keyword(CTerm::Fg, d.clone());
        let bg = Self::get_colour_keyword(CTerm::Bg, d.clone());

        rows.push(Row::from(vec![
          Cell::from("Detection").fg(Color::White),
          Cell::from(d.clone()).bg(bg).fg(fg),
        ]))
      }
      
      if let Some(d) = a.link {
        rows.push(Row::from(vec![
          Cell::from("Link").fg(Color::White),
          Cell::from(d).fg(Color::DarkCyan),
        ]));
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(a) = intel.docguard {
      rows.push(Row::from(vec![
        Cell::from("DocGuard").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue).fg(Color::White)
      ]));
      
      if let Some(al) = a.verdict {
        let fg = Self::get_colour_keyword(CTerm::Fg, al.clone());
        let bg = Self::get_colour_keyword(CTerm::Bg, al.clone());

        rows.push(Row::from(vec![
          Cell::from("Verdict").fg(Color::White),
          Cell::from(al.clone()).bg(bg).fg(fg),
        ]));
      }

      if let Some(al) = a.filetype {
        rows.push(Row::from(vec![
          Cell::from("File Type").fg(Color::White),
          Cell::from(al).fg(Color::Green)
        ]));
      }
      
      if let Some(al) = a.alertlevel {
        rows.push(Row::from(vec![
          Cell::from("Alert Level").fg(Color::White),
          Cell::from(al).fg(Color::Yellow),
        ]));
      }

      if let Some(al) = a.urls {
        let mut url_content = String::new();
        
        for idx in al {
          url_content.push_str(format!("{idx}\n").as_str());
        }

        url_content.pop();
        rows.push(Row::from(vec![
          Cell::from("Urls").fg(Color::Yellow),
          Cell::from(url_content).fg(Color::DarkCyan),
        ]));
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(a) = intel.filescan_io {
      rows.push(Row::from(vec![
        Cell::from("FileScan-IO").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue).fg(Color::White)
      ]));
      
      if let Some(f) = a.verdict {
        let fg = Self::get_colour_keyword(CTerm::Fg, f.clone());
        let bg = Self::get_colour_keyword(CTerm::Bg, f.clone());

        rows.push(Row::from(vec![
          Cell::from("Verdict").fg(Color::White),
          Cell::from(f.clone()).bg(bg).fg(fg),
        ]))
      }

      if let Some(f) = a.confidence {
        rows.push(Row::from(vec![
          Cell::from("Confidence").fg(Color::White),
          Cell::from(f).fg(Color::Cyan),
        ]))
      }

      if let Some(f) = a.threatlevel {
        rows.push(Row::from(vec![
          Cell::from("Threat Level").fg(Color::White),
          Cell::from(f).fg(Color::DarkYellow),
        ]))
      }

      if let Some(f) = a.report_link {
        rows.push(Row::from(vec![
          Cell::from("Report Link").fg(Color::White),
          Cell::from(f).fg(Color::DarkCyan),
        ]))
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(a) = intel.inquest {
      rows.push(Row::from(vec![
        Cell::from("InQuest").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue).fg(Color::White)
      ]));
      
      if let Some(q) = a.verdict {
        let fg = Self::get_colour_keyword(CTerm::Fg, q.clone());
        let bg = Self::get_colour_keyword(CTerm::Bg, q.clone());

        rows.push(Row::from(vec![
          Cell::from("Veridct").fg(Color::White),
          Cell::from(q.clone()).bg(bg).fg(fg),
        ]));
      }

      if let Some(q) = a.details {
        for idx in q {
          if let Some(i) = idx.title {
            rows.push(Row::from(vec![
              Cell::from("Title").fg(Color::White),
              Cell::from(i).fg(Color::Green),
            ]));
          }

          if let Some(i) = idx.category {
            rows.push(Row::from(vec![
              Cell::from("Category").fg(Color::White),
              Cell::from(i).fg(Color::Cyan),
            ]));
          }

          if let Some(i) = idx.description {
            rows.push(Row::from(vec![
              Cell::from("Description").fg(Color::White),
              Cell::from(i).fg(Color::Green),
            ]));
          }

          rows.push(Row::from(vec![
            Cell::from(""),
          ]));
        }
      }

      if let Some(q) = a.url {
        rows.push(Row::from(vec![
          Cell::from("Url").fg(Color::White),
          Cell::from(q).fg(Color::DarkCyan),
        ]));
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(a) = intel.reversinglabs {
      rows.push(Row::from(vec![
        Cell::from("Reversing Labs").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue).fg(Color::White)
      ]));
      
      if let Some(r) = a.status {
        let fg = Self::get_colour_keyword(CTerm::Fg, r.clone());
        let bg = Self::get_colour_keyword(CTerm::Bg, r.clone());

        rows.push(Row::from(vec![
          Cell::from("Status").fg(Color::White),
          Cell::from(r.clone()).bg(bg).fg(fg),
        ]));
      }

      if let Some(r) = a.threat_name {
        rows.push(Row::from(vec![
          Cell::from("Threat Name").fg(Color::White),
          Cell::from(r).fg(Color::Red),
        ]));
      }

      if let Some(r) = a.first_seen {
        rows.push(Row::from(vec![
          Cell::from("First Seen").fg(Color::White),
          Cell::from(r).fg(Color::White),
        ]));
      }

      if let Some(r) = a.scanner_count {
        rows.push(Row::from(vec![
          Cell::from("Scanner Count").fg(Color::White),
          Cell::from(r).fg(Color::Yellow),
        ]));
      }

      if let Some(r) = a.scanner_mount {
        rows.push(Row::from(vec![
          Cell::from("Scanner Mount").fg(Color::White),
          Cell::from(r).fg(Color::Yellow),
        ]));
      }

      if let Some(r) = a.scanner_percent {
        rows.push(Row::from(vec![
          Cell::from("Scanner %").fg(Color::White),
          Cell::from(r).fg(Color::Yellow),
        ]));
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(spam) = intel.spamhaus_hbl {
      rows.push(Row::from(vec![
        Cell::from("Spamhaus_HBL").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue).fg(Color::White)
      ]));
      
      for i in spam {
        if let Some(s) = i.detection {
          let fg = Self::get_colour_keyword(CTerm::Fg, s.clone());
          let bg = Self::get_colour_keyword(CTerm::Bg, s.clone());

          rows.push(Row::from(vec![
            Cell::from("Detection").fg(Color::White),
            Cell::from(s.clone()).bg(bg).fg(fg)
          ]));
        }

        if let Some(s) = i.link {
          rows.push(Row::from(vec![
            Cell::from("Link").fg(Color::White),
            Cell::from(s).fg(Color::DarkCyan),
          ]));
        }
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(s) = intel.intezer {
      rows.push(Row::from(vec![
        Cell::from("Intezer").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue),
      ]));

      if let Some(i) = s.verdict {
        let bg = Self::get_colour_keyword(CTerm::Bg, i.clone());
        let fg = Self::get_colour_keyword(CTerm::Fg, i.clone());
        
        rows.push(Row::from(vec![
          Cell::from("Verdict").fg(Color::White),
          Cell::from(i).fg(fg).bg(bg),
        ]));
      }
      
      if let Some(i) = s.family_name {
        rows.push(Row::from(vec![
          Cell::from("Family Name").fg(Color::White),
          Cell::from(i).fg(Color::Red),
        ]));
      }

      if let Some(i) = s.analysis_url {
        rows.push(Row::from(vec![
          Cell::from("Analysis Url").fg(Color::White),
          Cell::from(i).fg(Color::DarkCyan),
        ]));
      }
    }

    //////////////////////////////////////////////////////////////////////////////


    if let Some(t) = intel.triage {
      rows.push(Row::from(vec![
        Cell::from("Triage").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue),
      ]));
      
      if let Some(s) = t.malware_family {
        rows.push(Row::from(vec![
          Cell::from("Malware Family").fg(Color::White),
          Cell::from(s).fg(Color::Red),
        ]));
      }

      if let Some(s) = t.score {
        rows.push(Row::from(vec![
          Cell::from("Score").fg(Color::White),
          Cell::from(s).fg(Color::Yellow),
        ]));
      }

      if let Some(s) = t.link {
        rows.push(Row::from(vec![
          Cell::from("Link").fg(Color::White),
          Cell::from(s).fg(Color::DarkCyan),
        ]));
      }

      if let Some(s) = t.tags {
        let mut tags = String::new();
        
        for i in s {
          tags.push_str(i.as_str());
          tags.push('\n');
        }

        tags.pop();
        rows.push(Row::from(vec![
          Cell::from("Tags").fg(Color::White),
          Cell::from(tags).fg(Color::Green),
        ]));
      }

      if let Some(sig) = t.signatures {
        rows.push(Row::from(vec![
          Cell::from("Triage Sigantures").bg(Color::DarkGrey).fg(Color::White),
          Cell::from("").bg(Color::DarkGrey),
        ]));
        
        for i in sig {
          
          if let Some(s) = i.signature {
            rows.push(Row::from(vec![
              Cell::from("Signature").fg(Color::White),
              Cell::from(s).fg(Color::Red),
            ]));
          }

          if let Some(s) = i.score {
            rows.push(Row::from(vec![
              Cell::from("Score").fg(Color::White),
              Cell::from(s).fg(Color::Yellow),
            ]));
          }

          rows.push(Row::from(vec![
            Cell::from(""),
          ]));
        }
      }

      if let Some(cfg) = t.malware_config {
        rows.push(Row::from(vec![
          Cell::from("Triage Malware Configurations").bg(Color::DarkGrey).fg(Color::White),
          Cell::from("").bg(Color::DarkGrey),
        ]));

        for i in cfg {
          if let Some(s) = i.extraction {
            rows.push(Row::from(vec![
              Cell::from("Extraction").fg(Color::White),
              Cell::from(s).fg(Color::Red),
            ]));
          }

          if let Some(s) = i.family {
            rows.push(Row::from(vec![
              Cell::from("Family").fg(Color::White),
              Cell::from(s).fg(Color::Red),
            ]));
          }

          if let Some(s) = i.c2 {
            rows.push(Row::from(vec![
              Cell::from("C2").fg(Color::White),
              Cell::from(s).fg(Color::DarkCyan),
            ]));
          }

          rows.push(Row::from(vec![
            Cell::from(""),
          ]));
        }
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(a) = intel.vxcube {
      rows.push(Row::from(vec![
        Cell::from("VxCube").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue),
      ]));
      
      if let Some(s) = a.verdict {
        let bg = Self::get_colour_keyword(CTerm::Bg, s.clone());
        let fg = Self::get_colour_keyword(CTerm::Fg, s.clone());
        
        rows.push(Row::from(vec![
          Cell::from("Verdict").fg(Color::White),
          Cell::from(s).bg(bg).fg(fg),
        ]));
      }

      if let Some(s) = a.maliciousness {
        rows.push(Row::from(vec![
          Cell::from("Maliciousness").fg(Color::White),
          Cell::from(s).fg(Color::Yellow),
        ]));
      }

      if let Some(bh) = a.behaviour {
        rows.push(Row::from(vec![
          Cell::from("VxCube Behaviour").bg(Color::DarkGrey).fg(Color::White),
          Cell::from("").bg(Color::DarkGrey),
        ]));
        
        for i in bh {
          if let Some(s) = i.rule {
            rows.push(Row::from(vec![
              Cell::from("Rule").fg(Color::White),
              Cell::from(s).fg(Color::Red),
            ]));
          }

          if let Some(s) = i.threat_level {
            rows.push(Row::from(vec![
              Cell::from("Threat Level").fg(Color::White),
              Cell::from(s).fg(Color::Yellow),
            ]));
          }

          rows.push(Row::from(vec![
            Cell::from("")
          ]));
        }
      }
    }
    //////////////////////////////////////////////////////////////////////////////

    if let Some(a) = intel.yoroi_yomi {
      rows.push(Row::from(vec![
        Cell::from("Yoroi Yomi").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue),
      ]));

      if let Some(s) = a.detection {
        let bg = Self::get_colour_keyword(CTerm::Bg, s.clone());
        let fg = Self::get_colour_keyword(CTerm::Fg, s.clone());
        
        rows.push(Row::from(vec![
          Cell::from("Detection").fg(Color::White),
          Cell::from(s.clone()).bg(bg).fg(fg),
        ]));
      }

      if let Some(s) = a.score {
        rows.push(Row::from(vec![
          Cell::from("Score").fg(Color::White),
          Cell::from(s.clone()).fg(Color::Yellow),
        ]));
      }
    }
    //////////////////////////////////////////////////////////////////////////////
    if let Some(pack) = intel.unpack_me {
      rows.push(Row::from(vec![
        Cell::from("UnpackMe").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue),
      ]));
      
      for i in pack {
        if let Some(s) = i.sha256_hash {
          rows.push(Row::from(vec![
            Cell::from("SHA256 Hash").fg(Color::White),
            Cell::from(s.clone()).fg(Color::DarkCyan),
          ]));
        }

        if let Some(s) = i.sha1_hash {
          rows.push(Row::from(vec![
            Cell::from("SHA1 Hash").fg(Color::White),
            Cell::from(s.clone()).fg(Color::DarkCyan),
          ]));
        }

        if let Some(s) = i.md5_hash {
          rows.push(Row::from(vec![
            Cell::from("MD5 Hash").fg(Color::White),
            Cell::from(s.clone()).fg(Color::DarkCyan),
          ]));
        }
        
        if let Some(s) = i.detections {
          let mut detection = String::new();
          
          for idx in s {
            detection.push_str(idx.as_str());
            detection.push('\n');
          }

          detection.pop();
          rows.push(Row::from(vec![
            Cell::from("Detections").fg(Color::White),
            Cell::from(detection).fg(Color::Red),
          ]));
        }

        if let Some(s) = i.link {
          rows.push(Row::from(vec![
            Cell::from("Link").fg(Color::White),
            Cell::from(s.clone()).fg(Color::Yellow),
          ]));
        }

        rows.push(Row::from(vec![
          Cell::from("")
        ]));
      }
    }
    //////////////////////////////////////////////////////////////////////////////
    if let Some(a) = intel.vm_ray {
      rows.push(Row::from(vec![
        Cell::from("VMRay").bg(Color::DarkBlue).fg(Color::White),
        Cell::from("").bg(Color::DarkBlue),
      ]));
      
      if let Some(s) = a.verdict {
        let bg = Self::get_colour_keyword(CTerm::Bg, s.clone());
        let fg = Self::get_colour_keyword(CTerm::Fg, s.clone());
        
        rows.push(Row::from(vec![
          Cell::from("Verdict").fg(Color::White),
          Cell::from(s.clone()).fg(fg).bg(bg),
        ]));
      }

      if let Some(s) = a.malware_family {
        rows.push(Row::from(vec![
          Cell::from("Malware Family").fg(Color::White),
          Cell::from(s.clone()).fg(Color::Red),
        ]));
      }

      if let Some(s) = a.report_link {
        rows.push(Row::from(vec![
          Cell::from("Report Link").fg(Color::White),
          Cell::from(s.clone()).fg(Color::DarkCyan),
        ]));
      }
    }
    //////////////////////////////////////////////////////////////////////////////
    

    table.add_rows(rows);
    title.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);
    table.set_content_arrangement(comfy_table::ContentArrangement::DynamicFullWidth);

    out.title = title;
    out.contents = table;
    Some(out)
  }


  /**Function queries the malware bazaar APU for a single hash.
   * Params:
   *  apikey: String  {The malware bazaar API key}
   *  hash: String    {The file hash}
   * Returns Result<String, GeneralError>
   */
  pub fn query_hash(apikey: &String, hash: String) -> std::result::Result<String, GeneralError> {
    let builder = ClientBuilder::new()
    .build()?
    .request(Method::POST, mb_consts::URL)
    .header(ACCEPT, "application/json")
    .header(HOST, mb_consts::HOST)
    .header(USER_AGENT, "PE Potato 0.1.0")
    .header("API-KEY", apikey)
    .header(CONTENT_LENGTH, 100)
    .form(&[("query", mb_consts::G_INFO), ("hash", hash.as_str())]);
    
    let response = builder.send()?;
    let text = response.text()?;
    
    Ok(text)
  }
}



